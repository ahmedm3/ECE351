`timescale 1ns / 1ps
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// 	Project #1 - ECE 351 (Portland State University)
//	Developed by Harsh Momaya and modified by Ahmed Abdulkareem
//
//	Project: 8 bit ALU design using Verilog HDL
//
//  Following functions should be implemented :
//		Add with carry
//		Subtract with borrow
//		Logical Shift left and right
//		Rotate right and left
//		Logical functions- AND, OR, NOT, NAND, NOR, XOR and XNOR
//  Combinational design using behavioral and data flow modeling
//
//
//   												Function table
//											------------------------
// 										 	 sel value 			function
//  											 0000				Add
//	 											 0001				Subtract
//	 											 0010				Shift left
//	 											 0011				Shift right
//	 											 0100				Rotate left
//	 											 0101				Rotate right
//	 											 0110				AND
//	 											 0111				OR
//	 											 1000				NOT
//	 											 1001				NAND
//	 											 1010				NOR
//	 											 1011				XOR
//	 										   	 1100				XNOR
//
//			I/O				Description
//	--------------------------------------
//			A, B			Two 8-bit inputs to the ALU
//			carry_in		Carry in(generated from previous circuit)
//			sel				4-bit input to select the desired function
//			Y				8-bit output signal
//			carry_out		Indicating carry/borrow generated by the ALU
//
//  NOTE:  This model is incomplete  but implements the microarchitecture called out in the ALU specification
//  (with most of the code missing).  You may use it to build your ALU if you'd like but are not
//	required to do so (RK, 05-May-2016)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////

module alu_design (
	input wire [7:0]  A,B,
	input wire carry_in,
	input wire [3:0]  sel,
	output reg [7:0] Y, 
	output reg  carry_out
);
					
					
 	// internal signals declaration
	wire [7:0] addSub_out, rotate_out, shift_out, logical_out;
	reg [4:0] op_en;
	reg dir; 
	wire addSub_cout;	  	
	wire [3:0] out_en;

        // defined op_en inputs
        localparam ADD = 4'b0000, SUB = 4'b0001, SHIFT_LEFT = 4'b0010, SHIFT_RIGHT = 4'b0011, ROTATE_LEFT = 4'b0100, ROTATE_RIGHT = 4'b0101, AND = 4'b0110, OR = 4'b0111, NOT = 4'b1000, NAND = 4'b1001, NOR = 4'b1010, XOR = 4'b1011, XNOR = 4'b1100;
		
	// adder_subtractor unit instance
	adder_sub unit1 (
		.A(A), 
		.B(B),
		.sub_en(op_en[1]),
		.add_en(op_en[0]),
		.out_en(out_en[0]),
		.carry_in(carry_in),
		.data_out(addSub_out),		
		.carry_out(addSub_cout)
	);
        	 
	// Shift unit instance
	shift_unit unit2 (
		.data_in(A), 
		.shift_by(B),
		.op_en(op_en[2]), 
		.dir(dir),
		.data_out(shift_out),
		.out_en(out_en[1])					
	);
								
								
	// rotate unit instance
	rotate_unit unit3 (
		.data_in(A), 
		.rotate_by(B),
		.op_en(op_en[3]), 
		.dir(dir),
		.data_out(rotate_out),
		.out_en(out_en[2])					
	);
	
	// logical unit instance						
	logical_unit unit4 (
		.A(A),
		.B(B),
		.fn_sel(sel),
		.op_en(op_en[4]),
		.out_en(out_en[3]),
		.data_out(logical_out)
	);
						 
	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	//													OPERATION ENABLE LOGIC
	//
	//
	//													Operation enable table
	// 								 	op_en (5 bits)							OPERATION
	//									----------------------------------------------------------
	//										  00001								ADD
	//										  00010								SUB
	//										  00100                             Shift
	//										  01000                             Rotate	
	//										  10000								Logical function
	//
	//													 direction (dir- 1 bit)
	//													------------------------
	//  														0 -> right
	//  														1 -> left
	//
	///////////////////////////////////////////////////////////////////////////////////////////////////////////

	always @* begin
	    case (sel)
                ADD         : op_en = 5'b00001;
                SUB         : op_en = 5'b00010;
                SHIFT_LEFT  : begin op_en = 5'b00100; dir = 1'b1; end
                SHIFT_RIGHT : begin op_en = 5'b00100; dir = 1'b0; end
                ROTATE_LEFT : begin op_en = 5'b01000; dir = 1'b1; end
                ROTATE_RIGHT: begin op_en = 5'b01000; dir = 1'b0; end
                AND, OR, NOT, NAND, XOR, NOR, XNOR: op_en = 5'b10000;
                default     : op_en = 5'b00000;
            endcase
	end
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	//														OUTPUT ENABLE LOGIC
	//
	//													   output enable table	
	//									 out_en value (4 bits)  				   OPERATION
	//									 --------------------------------------------------
	//										0001          					add_sub unit
	//										0010                			shift
	//										0100              	 			rotate
	//										1000							logical unit
	//									
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	always @* begin
	    case (out_en)
                4'b0001: begin Y = addSub_out; carry_out = addSub_cout; end
                4'b0010: Y = shift_out;
                4'b0100: Y = rotate_out;
                4'b1000: Y = logical_out;
                default: Y = 8'bxxxxxxxx;
            endcase
	end
endmodule	

